// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Linq;
using System.Threading.Tasks;
using NuGet.Services.Entities;
using NuGet.Versioning;
using NuGetGallery;

namespace GitHubVulnerability2Db.Ingest
{
    public class VulnerabilityPersistenceService : IVulnerabilityPersistenceService
    {
        public VulnerabilityPersistenceService(
            IEntitiesContext entitiesContext,
            IPackageUpdateService packageUpdateService)
        {
            _entitiesContext = entitiesContext ?? throw new ArgumentNullException(nameof(entitiesContext));
            _packageUpdateService = packageUpdateService ?? throw new ArgumentNullException(nameof(packageUpdateService));
        }

        private readonly IEntitiesContext _entitiesContext;
        private readonly IPackageUpdateService _packageUpdateService;

        public async Task UpdateVulnerabilityInformation(PackageVulnerability vulnerability, bool wasWithdrawn)
        {
            using (var strategy = new SuspendDbExecutionStrategy())
            using (var transaction = _entitiesContext.GetDatabase().BeginTransaction())
            {
                var existingVulnerability = _entitiesContext.Vulnerabilities
                    .Include(p => p.VulnerablePackages)
                    .FirstOrDefault(v => v.GitHubDatabaseKey == vulnerability.GitHubDatabaseKey);

                var packagesToUpdate = new List<Package>();
                if (existingVulnerability == null)
                {
                    // We have not yet added this vulnerability's information to the database.
                    if (wasWithdrawn)
                    {
                        // We don't persist information about vulnerabilities that were withdrawn.
                        return;
                    }

                    _entitiesContext.Vulnerabilities.Add(vulnerability);
                    MarkPackagesMatchingVulnerabilityAsVulnerable(vulnerability, packagesToUpdate);
                }
                else
                {
                    // This vulnerability is already in the database and needs to be updated.
                    if (wasWithdrawn)
                    {
                        // This vulnerability has been withdrawn. The packages that were previously marked vulnerable to it should be updated.
                        packagesToUpdate.AddRange(existingVulnerability.VulnerablePackages);
                        foreach (var package in existingVulnerability.VulnerablePackages)
                        {
                            package.Vulnerabilities.Remove(existingVulnerability);
                        }

                        _entitiesContext.Vulnerabilities.Remove(existingVulnerability);
                    }
                    else
                    {
                        // This vulnerability had its metadata updated.
                        var wasUpdated = false;
                        if (vulnerability.PackageId != existingVulnerability.PackageId)
                        {
                            wasUpdated = true;
                            existingVulnerability.PackageId = vulnerability.PackageId;
                        }

                        if (vulnerability.PackageVersionRange != existingVulnerability.PackageVersionRange)
                        {
                            wasUpdated = true;
                            existingVulnerability.PackageVersionRange = vulnerability.PackageVersionRange;
                        }

                        CheckPackagesMarkedVulnerableAreStillVulnerable(existingVulnerability, packagesToUpdate, wasUpdated);
                        MarkPackagesMatchingVulnerabilityAsVulnerable(existingVulnerability, packagesToUpdate);
                    }
                }

                await _entitiesContext.SaveChangesAsync();

                if (packagesToUpdate.Any())
                {
                    await _packageUpdateService.UpdatePackagesAsync(packagesToUpdate);
                }

                transaction.Commit();
            }
        }

        private void MarkPackagesMatchingVulnerabilityAsVulnerable(PackageVulnerability vulnerability, List<Package> packagesToUpdate)
        {
            var versionRange = GetVersionRangeFromVulnerability(vulnerability);
            foreach (var potentiallyVulnerablePackage in GetPackagesWithSameIdAsVulnerability(vulnerability))
            {
                var version = NuGetVersion.Parse(potentiallyVulnerablePackage.NormalizedVersion);
                if (versionRange.Satisfies(version))
                {
                    var isAlreadyVulnerable = vulnerability.VulnerablePackages.Contains(potentiallyVulnerablePackage);
                    if (!isAlreadyVulnerable)
                    {
                        potentiallyVulnerablePackage.Vulnerabilities.Add(vulnerability);
                        vulnerability.VulnerablePackages.Add(potentiallyVulnerablePackage);
                        packagesToUpdate.Add(potentiallyVulnerablePackage);
                    }
                }
            }
        }

        private void CheckPackagesMarkedVulnerableAreStillVulnerable(PackageVulnerability vulnerability, List<Package> packagesToUpdate, bool wasUpdated)
        {
            var versionRange = GetVersionRangeFromVulnerability(vulnerability);
            foreach (var existingVulnerablePackage in vulnerability.VulnerablePackages)
            {
                var version = NuGetVersion.Parse(existingVulnerablePackage.NormalizedVersion);
                var satisfiesVersionRange = versionRange.Satisfies(version);
                if (!satisfiesVersionRange)
                {
                    existingVulnerablePackage.Vulnerabilities.Remove(vulnerability);
                    vulnerability.VulnerablePackages.Remove(existingVulnerablePackage);
                }

                if (!satisfiesVersionRange || wasUpdated)
                {
                    packagesToUpdate.Add(existingVulnerablePackage);
                }
            }
        }

        private IReadOnlyCollection<Package> GetPackagesWithSameIdAsVulnerability(PackageVulnerability vulnerability)
        {
            return _entitiesContext.PackageRegistrations
                .Where(pr => pr.Id == vulnerability.PackageId)
                .SelectMany(pr => pr.Packages)
                .ToList();
        }

        private VersionRange GetVersionRangeFromVulnerability(PackageVulnerability vulnerability)
        {
            return VersionRange.Parse(vulnerability.PackageVersionRange);
        }
    }
}