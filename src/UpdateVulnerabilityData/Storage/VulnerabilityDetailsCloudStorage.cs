// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.WindowsAzure.Storage;
using Microsoft.WindowsAzure.Storage.Blob;
using Newtonsoft.Json;
using NuGetGallery;

namespace UpdateVulnerabilityData.Storage
{
    public class VulnerabilityDetailsCloudStorage
        : IVulnerabilityDetailsStorage
    {
        public const string CveMetaFilesReferenceBlobName = "cve-meta-reference.json";
        public const string SourceETagKey = "SourceETag";

        private const string ContentTypePlainText = "text/plain";
        private const string ContentTypeZip = "application/zip";
        private const string ContentTypeJson = "application/json";

        private readonly string _fileNamePrefix;
        private readonly ICloudBlobContainer _cloudBlobContainer;
        private readonly ILogger<VulnerabilityDetailsCloudStorage> _logger;
        private readonly BlobContainerPermissions _blobContainerPermissions
            = new BlobContainerPermissions { PublicAccess = BlobContainerPublicAccessType.Off };

        private bool _initialized;

        public VulnerabilityDetailsCloudStorage(
            ICloudBlobClient cloudBlobClient,
            string containerName,
            ILogger<VulnerabilityDetailsCloudStorage> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            if (cloudBlobClient == null)
            {
                throw new ArgumentNullException(nameof(cloudBlobClient));
            }

            _cloudBlobContainer = cloudBlobClient.GetContainerReference(containerName ?? throw new ArgumentNullException(nameof(containerName)));
            _fileNamePrefix = DateTime.UtcNow.ToString("yyyy/MM/dd/HHmmss");
        }

        public Task<bool> WriteSourceDataFileAsync(
            Stream inputStream,
            string destinationFileName,
            ContentType destinationContentType,
            string eTag)
        {
            return UploadBlobAsync(
                inputStream,
                $"{_fileNamePrefix}/{destinationFileName}",
                destinationContentType,
                eTag);
        }

        private async Task<bool> UploadBlobAsync(
            Stream inputStream,
            string blobName,
            ContentType destinationContentType,
            string sourceETag = null,
            bool overwrite = false)
        {
            if (!_initialized)
            {
                await InitializeAsync();
            }

            try
            {
                var blobReference = _cloudBlobContainer.GetBlobReference(blobName);
                blobReference.Properties.ContentType = GetContentType(destinationContentType);

                if (sourceETag != null)
                {
                    blobReference.Metadata[SourceETagKey] = sourceETag;
                }

                _logger.LogInformation(
                    "Start to write to {DestinationFileName}. ContentType is {ContentType}.",
                    blobReference.Uri,
                    blobReference.Properties.ContentType);

                if (!overwrite && await blobReference.ExistsAsync())
                {
                    _logger.LogWarning(
                        "The destination file {DestinationFileName} was already present.",
                        blobReference.Uri);

                    return false;
                }

                await blobReference.UploadFromStreamAsync(inputStream, overwrite);

                _logger.LogInformation(
                    "The destination file {DestinationFileName} was created successfully.",
                    blobReference.Uri);

                return true;
            }
            catch (StorageException storageException)
            {
                _logger.LogError(
                    Error.FailedToUploadBlob,
                    storageException,
                    "Failed to upload file to destination {DestinationFileName}.",
                    blobName);

                return false;
            }
        }

        private async Task<bool> DownloadFileAsync(string blobName, Stream target)
        {
            try
            {
                var blobReference = _cloudBlobContainer.GetBlobReference(blobName);
                if (!await blobReference.ExistsAsync())
                {
                    // Log as warning instead of error.
                    // Up to the caller to decide whether this is critical or not.
                    _logger.LogWarning(
                        Error.FailedToDownloadBlob,
                        "Failed to download file from origin {OriginFileName}: file does not exist.",
                        blobName);

                    return false;
                }

                _logger.LogInformation(
                    "Start to download from {OriginFileName}. ContentType is {ContentType}.",
                    blobReference.Uri,
                    blobReference.Properties.ContentType);

                await blobReference.DownloadToStreamAsync(target);

                _logger.LogInformation(
                    "The origin file {OriginFileName} was downloaded successfully.",
                    blobReference.Uri);

                return true;

            }
            catch (StorageException storageException)
            {
                _logger.LogError(
                    Error.FailedToDownloadBlob,
                    storageException,
                    "Failed to download file from origin {OriginFileName}.",
                    blobName);

                return false;
            }
        }

        private async Task InitializeAsync()
        {
            if (_initialized) return;

            await _cloudBlobContainer.CreateIfNotExistAsync();
            await _cloudBlobContainer.SetPermissionsAsync(_blobContainerPermissions);

            _initialized = true;
        }

        private string GetContentType(ContentType contentType)
        {
            switch (contentType)
            {
                case ContentType.PlainText:
                    return ContentTypePlainText;
                case ContentType.Zip:
                    return ContentTypeZip;
                case ContentType.Json:
                    return ContentTypeJson;
                default:
                    throw new ArgumentOutOfRangeException(nameof(contentType));
            }
        }

        public async Task<bool> WriteCveMetaFilesReferenceAsync(CveMetaFilesReference reference, bool overwrite = false)
        {
            var json = JsonConvert.SerializeObject(reference);

            bool success;
            using (var memoryStream = new MemoryStream())
            using (var writer = new StreamWriter(memoryStream))
            {
                writer.Write(json);
                writer.Flush();

                memoryStream.Position = 0;

                success = await UploadBlobAsync(
                    memoryStream,
                    CveMetaFilesReferenceBlobName,
                    ContentType.Json,
                    overwrite: overwrite);
            }

            return success;
        }

        public async Task<CveMetaFilesReference> ReadCveMetaFilesReferenceAsync()
        {
            bool downloadSuccess;
            string json = null;
            using (var memoryStream = new MemoryStream())
            {
                downloadSuccess = await DownloadFileAsync(CveMetaFilesReferenceBlobName, memoryStream);

                if (downloadSuccess)
                {
                    memoryStream.Position = 0;

                    using (var reader = new StreamReader(memoryStream))
                    {
                        json = reader.ReadToEnd();
                    }
                }
            }

            if (downloadSuccess && !string.IsNullOrWhiteSpace(json))
            {
                return JsonConvert.DeserializeObject<CveMetaFilesReference>(json);
            }

            return null;
        }
    }
}