// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.WindowsAzure.Storage;
using Microsoft.WindowsAzure.Storage.Blob;
using NuGetGallery;

namespace UpdateVulnerabilityData.Storage
{
    public class CloudStorageBackupDestination
        : IBackupDestination
    {
        public const string SourceETagKey = "SourceETag";

        private const string ContentTypePlainText = "text/plain";
        private const string ContentTypeZip = "application/zip";
        private const string ContentTypeJson = "application/json";

        private readonly string _fileNamePrefix;
        private readonly ICloudBlobContainer _cloudBlobContainer;
        private readonly ILogger<CloudStorageBackupDestination> _logger;
        private readonly BlobContainerPermissions _blobContainerPermissions
            = new BlobContainerPermissions { PublicAccess = BlobContainerPublicAccessType.Off };

        private bool _initialized;

        public CloudStorageBackupDestination(
            ICloudBlobClient cloudBlobClient,
            string containerName,
            ILogger<CloudStorageBackupDestination> logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));

            if (cloudBlobClient == null)
            {
                throw new ArgumentNullException(nameof(cloudBlobClient));
            }

            _cloudBlobContainer = cloudBlobClient.GetContainerReference(containerName ?? throw new ArgumentNullException(nameof(containerName)));
            _fileNamePrefix = DateTime.UtcNow.ToString("yyyy/MM/dd/HHmmss");
        }

        public async Task<bool> WriteAsync(
            Stream inputStream,
            string destinationFileName,
            ContentType destinationContentType,
            string eTag)
        {
            if (!_initialized)
            {
                await InitializeAsync();
            }

            var blobName = $"{_fileNamePrefix}/{destinationFileName}";

            try
            {
                var blobReference = _cloudBlobContainer.GetBlobReference(blobName);
                blobReference.Properties.ContentType = GetContentType(destinationContentType);
                blobReference.Metadata[SourceETagKey] = eTag;

                _logger.LogInformation(
                    "WriteAsync: Start to write to {DestinationFileName}. ContentType is {ContentType}.",
                    blobReference.Uri,
                    blobReference.Properties.ContentType);

                if (await blobReference.ExistsAsync())
                {
                    _logger.LogWarning(
                        "WriteAsync: The destination file {DestinationFileName} was already present.",
                        blobReference.Uri);

                    return false;
                }

                await blobReference.UploadFromStreamAsync(inputStream, overwrite: false);

                _logger.LogInformation(
                    "WriteAsync: The destination file {DestinationFileName}, was created successfully.",
                    blobReference.Uri);

                return true;
            }
            catch (StorageException storageException)
            {
                _logger.LogError(
                    Error.FailedToBackupSourceFile,
                    storageException,
                    "WriteAsync: Failed to backup source file to destination {DestinationFileName}.",
                    blobName);

                return false;
            }
        }

        private async Task InitializeAsync()
        {
            if (_initialized) return;

            await _cloudBlobContainer.CreateIfNotExistAsync();
            await _cloudBlobContainer.SetPermissionsAsync(_blobContainerPermissions);

            _initialized = true;
        }

        private string GetContentType(ContentType contentType)
        {
            switch (contentType)
            {
                case ContentType.PlainText:
                    return ContentTypePlainText;
                case ContentType.Zip:
                    return ContentTypeZip;
                case ContentType.Json:
                    return ContentTypeJson;
                default:
                    throw new ArgumentOutOfRangeException(nameof(contentType));
            }
        }
    }
}
