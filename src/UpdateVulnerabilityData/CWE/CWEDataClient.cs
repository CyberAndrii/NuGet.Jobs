// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using UpdateVulnerabilityData.Storage;

namespace UpdateVulnerabilityData.CWE
{
    public class CweDataClient : VulnerabilityDataClient, ICweDataClient
    {
        private static readonly string LocalDataImportFolder = Path.Combine(Environment.CurrentDirectory, "CWE-data-import");
        private static readonly string LocalDataExportFolder = Path.Combine(Environment.CurrentDirectory, "CWE-data-export");
        private static readonly string PathToDownloadedArchive = Path.Combine(LocalDataImportFolder, "cwe-data.zip");

        private readonly ICweCsvFileParser _csvFileParser;
        private readonly ICweDataDownloader _cweDataDownloader;

        public CweDataClient(
            ICweCsvFileParser csvFileParser,
            ICweDataDownloader cweDataDownloader,
            ILogger<CweDataClient> logger,
            IOptionsSnapshot<UpdateVulnerabilityDataConfiguration> configuration,
            IVulnerabilityDetailsStorage storage,
            ITelemetryService telemetryService)
            : base(configuration, logger, storage, telemetryService)
        {
            _csvFileParser = csvFileParser ?? throw new ArgumentNullException(nameof(csvFileParser));
            _cweDataDownloader = cweDataDownloader ?? throw new ArgumentNullException(nameof(cweDataDownloader));
        }

        public async Task ImportCweDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory)
        {
            if (sqlConnectionFactory == null)
            {
                throw new ArgumentNullException(nameof(sqlConnectionFactory));
            }

            // Ensure the target folders exist and are clean.
            PrepareLocalDirectories(LocalDataImportFolder, LocalDataExportFolder);

            // Fetch CWE data for the 'Development Concepts' view.
            var downloadResult = await _cweDataDownloader.DownloadAndExtractCsvDataToDiskAsync(PathToDownloadedArchive);

            // Parse the CSV-formatted source file.
            var csvDocument = _csvFileParser.Parse(downloadResult.FilePath);

            // Import projected data into database.
            await ImportIntoDatabaseAsync(sqlConnectionFactory, csvDocument);

            // Save source data to backup location.
            await BackupSourceDataAsync(PathToDownloadedArchive, downloadResult.ETag, ContentType.Zip);
        }

        public async Task UpdateCweDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory)
        {
            throw new NotImplementedException();
        }

        private async Task ImportIntoDatabaseAsync(
            Func<Task<SqlConnection>> sqlConnectionFactory,
            CweCsvDocument csvDocument)
        {
            // Import assumes clear target tables.
            using (var sqlConnection = await sqlConnectionFactory())
            {
                var dataTable = GetDataTable(SqlTable.Cwes, sqlConnection);

                foreach (var cwe in csvDocument.Entries)
                {
                    var cweId = $"CWE-{cwe.CweId}";

                    var dataRow = dataTable.NewRow();
                    dataRow["CweId"] = cweId;
                    dataRow["Name"] = cwe.Name;
                    dataRow["Description"] = cwe.Description;

                    var status = CweHelper.DetermineStatus(cwe.Status);
                    dataRow["Status"] = status;
                    dataRow["Listed"] = CweHelper.DetermineListed(status);

                    dataTable.Rows.Add(dataRow);
                }

                var sqlBulkCopy = CreateNewSqlBulkCopy(sqlConnection, dataTable.TableName);

                // This avoids identity insert issues, as these are db-generated.
                foreach (DataColumn column in dataTable.Columns)
                {
                    sqlBulkCopy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                }

                await sqlBulkCopy.WriteToServerAsync(dataTable);
            }
        }
    }
}