// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;

namespace UpdateVulnerabilityData
{
    public class CveMetaFileProperties
    {
        private const string LastModifiedDateKey = "lastModifiedDate";
        private const string Sha256Key = "sha256";

        public CveMetaFileProperties(string sha256, DateTime lastModifiedDate)
        {
            Sha256 = sha256 ?? throw new ArgumentNullException(nameof(sha256));
            LastModifiedDate = lastModifiedDate;
        }

        public string Sha256 { get; }
        public DateTime LastModifiedDate { get; }

        public static CveMetaFileValidationResult TryCreateFromDictionary(IDictionary<string, string> metadata, out CveMetaFileProperties metaFileProperties)
        {
            if (metadata == null)
            {
                throw new ArgumentNullException(nameof(metadata));
            }

            // Verify well-known and required key-value pairs are available.
            // In particular, we require "lastModifiedDate" and "sha256" to verify CVE data files for validity and changes.
            var errorMessages = new List<string>();

            var lastModifiedDate = TryGetDateValue(metadata, LastModifiedDateKey, errorMessages);
            var sha256 = TryGetStringValue(metadata, Sha256Key, errorMessages);

            if (errorMessages.Any())
            {
                metaFileProperties = null;
                return CveMetaFileValidationResult.Fail(errorMessages);
            }

            metaFileProperties = new CveMetaFileProperties(sha256, lastModifiedDate.Value);

            return CveMetaFileValidationResult.Success;
        }

        private static DateTime? TryGetDateValue(IDictionary<string, string> metadata, string key, IList<string> errorMessages)
        {
            if (metadata.TryGetValue(key, out var dateString))
            {
                // Validate the date.
                if (!DateTime.TryParse(dateString, out var date))
                {
                    errorMessages.Add($"Key invalid: {key} ('{dateString}' is not in a valid date format)");
                }

                return date;
            }
            else
            {
                errorMessages.Add($"Key not found: {key}");
            }

            return null;
        }

        private static string TryGetStringValue(IDictionary<string, string> metadata, string key, IList<string> errorMessages)
        {
            if (metadata.TryGetValue(key, out var value))
            {
                return value;
            }
            else
            {
                errorMessages.Add($"Key not found: {key}");
            }

            return null;
        }
    }
}