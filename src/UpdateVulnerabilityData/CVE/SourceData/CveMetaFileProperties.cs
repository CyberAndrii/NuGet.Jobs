// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Linq;

namespace UpdateVulnerabilityData
{
    /// <summary>
    /// Represents the contents of a CVE .META file.
    /// </summary>
    public sealed class CveMetaFileProperties
    {
        private const string LastModifiedDateKey = "lastModifiedDate";
        private const string Sha256Key = "sha256";
        private const string ZipSizeKey = "zipSize";
        private const string JsonSizeKey = "size";

        private CveMetaFileProperties(
            string sha256,
            DateTime lastModifiedDate,
            long zipSize,
            long jsonSize)
        {
            Sha256 = sha256 ?? throw new ArgumentNullException(nameof(sha256));
            LastModifiedDate = lastModifiedDate;
            ZipSize = zipSize;
            JsonSize = jsonSize;
        }

        /// <summary>
        /// Gets the SHA-256 hash of the extracted JSON file containing CVE data.
        /// </summary>
        public string Sha256 { get; }

        /// <summary>
        /// Gets the last modified date for CVE data in this file.
        /// </summary>
        public DateTime LastModifiedDate { get; }

        /// <summary>
        /// Gets the file size in bytes for the ZIP archive. 
        /// </summary>
        public long ZipSize { get; }

        /// <summary>
        /// Gets the file size in bytes for the extracted JSON data file.
        /// </summary>
        public long JsonSize { get; }

        public static CveMetaFileValidationResult TryCreateFromDictionary(IDictionary<string, string> metadata, out CveMetaFileProperties metaFileProperties)
        {
            if (metadata == null)
            {
                throw new ArgumentNullException(nameof(metadata));
            }

            // Verify well-known and required key-value pairs are available.
            // In particular, we require "lastModifiedDate" and "sha256" to verify CVE data files for validity and changes.
            var errorMessages = new List<string>();

            var lastModifiedDate = TryGetDateValue(metadata, LastModifiedDateKey, errorMessages);
            var sha256 = TryGetStringValue(metadata, Sha256Key, errorMessages);
            var zipSize = TryGetLongValue(metadata, ZipSizeKey, errorMessages);
            var jsonSize = TryGetLongValue(metadata, JsonSizeKey, errorMessages);

            if (errorMessages.Any())
            {
                metaFileProperties = null;
                return CveMetaFileValidationResult.Fail(errorMessages);
            }

            metaFileProperties = new CveMetaFileProperties(
                sha256,
                lastModifiedDate.Value,
                zipSize.Value,
                jsonSize.Value);

            return CveMetaFileValidationResult.Success;
        }

        private static DateTime? TryGetDateValue(IDictionary<string, string> metadata, string key, IList<string> errorMessages)
        {
            var dateString = TryGetStringValue(metadata, key, errorMessages);

            if (dateString != null)
            {
                // Validate the date.
                if (!DateTime.TryParse(dateString, out var date))
                {
                    errorMessages.Add($"Key invalid: {key} ('{dateString}' is not a valid date)");
                    return null;
                }

                return date;
            }

            return null;
        }

        private static long? TryGetLongValue(IDictionary<string, string> metadata, string key, IList<string> errorMessages)
        {
            var longString = TryGetStringValue(metadata, key, errorMessages);

            if (longString != null)
            {
                // Validate the number.
                if (!long.TryParse(longString, out var value))
                {
                    errorMessages.Add($"Key invalid: {key} ('{longString}' is not a valid 64-bit integer)");
                    return null;
                }

                return value;
            }

            return null;
        }

        private static string TryGetStringValue(IDictionary<string, string> metadata, string key, IList<string> errorMessages)
        {
            if (metadata.TryGetValue(key, out var value))
            {
                return value;
            }
            else
            {
                errorMessages.Add($"Key not found: {key}");
            }

            return null;
        }
    }
}