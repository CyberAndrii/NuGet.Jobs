// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace UpdateVulnerabilityData.CVE
{
    public class CveDataDownloader : FileDownloader, ICveDataDownloader
    {
        public const string SourceFeedUrl = "https://nvd.nist.gov/feeds/json/cve/1.0/";
        public const string SourceFileFormat = "nvdcve-1.0-{0}.json.zip";
        public const string SourceFileUrlFormat = SourceFeedUrl + SourceFileFormat;
        public const string SourceMetaFileFormat = "nvdcve-1.0-{0}.meta";
        public const string SourceMetaFileUrlFormat = SourceFeedUrl + SourceMetaFileFormat;

        private readonly ICveMetaFileParser _cveMetaFileParser;

        public CveDataDownloader(
            HttpClient httpClient,
            ILogger<CveDataDownloader> logger,
            ICveMetaFileParser cveMetaFileParser)
            : base(httpClient, logger)
        {
            _cveMetaFileParser = cveMetaFileParser ?? throw new ArgumentNullException(nameof(cveMetaFileParser));
        }

        public async Task<CveFileDownloadResult> DownloadAndExtractJsonDataToDiskAsync(
            int year,
            string targetFilePath,
            CveMetaFileDownloadResult metaFileInfo)
        {
            if (targetFilePath == null)
            {
                throw new ArgumentNullException(nameof(targetFilePath));
            }

            if (year < 2002 || year > DateTime.UtcNow.Year)
            {
                throw new ArgumentOutOfRangeException(nameof(year), "The requested year has no CVE data available.");
            }

            var sourceFileUrl = string.Format(CultureInfo.InvariantCulture, SourceFileUrlFormat, year);

            try
            {
                var fileDownloadResult = await DownloadFileAsync(sourceFileUrl, targetFilePath);

                using (var archive = ZipFile.OpenRead(targetFilePath))
                {
                    var targetDirectory = new FileInfo(targetFilePath).Directory.FullName;

                    // The archive should only contain a single JSON file.
                    var jsonFile = archive.Entries.SingleOrDefault(e => e.FullName.EndsWith(".json", StringComparison.OrdinalIgnoreCase));
                    if (jsonFile == null)
                    {
                        Logger.LogError(
                            Error.FailedToExtractCveData,
                            "The CVE data archive for {Year} from {SourceUri} does not contain a single JSON file.",
                            year,
                            sourceFileUrl);

                        // This error should not block processing other data files.
                        return new CveFileDownloadResult(Error.FailedToExtractCveData, year);
                    }

                    // Gets the full path to ensure that relative segments are removed.
                    var pathToExtractedJsonFile = Path.GetFullPath(Path.Combine(targetDirectory, jsonFile.FullName));

                    // Ordinal match is safest, case-sensitive volumes can be mounted within volumes that
                    // are case-insensitive.
                    string jsonFileSha256 = null;
                    if (pathToExtractedJsonFile.StartsWith(targetDirectory, StringComparison.Ordinal))
                    {
                        jsonFile.ExtractToFile(pathToExtractedJsonFile, overwrite: true);

                        using (var jsonFileStream = File.OpenRead(pathToExtractedJsonFile))
                        {
                            jsonFileSha256 = CalculateSha256(jsonFileStream);
                        }
                    }

                    return new CveFileDownloadResult(
                        pathToExtractedJsonFile,
                        fileDownloadResult.ETag,
                        jsonFileSha256,
                        year,
                        targetFilePath);
                }
            }
            catch (InvalidOperationException e)
            {
                Logger.LogError(
                    Error.FailedToDownloadCveData,
                    e,
                    "Exception thrown when trying to download CVE data for {Year} from {SourceUri}",
                    year,
                    sourceFileUrl);

                // This error should not block processing other data files.
                return new CveFileDownloadResult(Error.FailedToDownloadCveData, year);
            }
        }

        public async Task<CveMetaFileDownloadResult> DownloadAndParseSourceMetaFileAsync(int year, string targetFilePath)
        {
            if (targetFilePath == null)
            {
                throw new ArgumentNullException(nameof(targetFilePath));
            }

            if (year < 2002 || year > DateTime.UtcNow.Year)
            {
                throw new ArgumentOutOfRangeException(nameof(year), "The requested year has no CVE data available.");
            }

            var sourceMetaFileUrl = string.Format(CultureInfo.InvariantCulture, SourceMetaFileUrlFormat, year);

            try
            {
                var fileDownloadResult = await DownloadFileAsync(sourceMetaFileUrl, targetFilePath);

                // Parse the META file contents.
                var metadata = _cveMetaFileParser.Parse(fileDownloadResult.FilePath);

                // Validate the metadata.
                var validationResult = CveMetaFileProperties.TryCreateFromDictionary(metadata, out var metaFileProperties);

                if (validationResult.HasErrors)
                {
                    Logger.LogError(
                        Error.FailedToParseCveMetaData,
                        "Failed to parse CVE META file for {Year} from {SourceUri}: {ValidationErrors}",
                        year,
                        sourceMetaFileUrl,
                        string.Join(",", validationResult.ErrorMessages));

                    // This error should not block processing other data files.
                    return new CveMetaFileDownloadResult(Error.FailedToParseCveMetaData, year);
                }

                return new CveMetaFileDownloadResult(
                        fileDownloadResult.FilePath,
                        fileDownloadResult.ETag,
                        fileDownloadResult.Sha256,
                        year,
                        metaFileProperties);
            }
            catch (InvalidOperationException e)
            {
                Logger.LogError(
                    Error.FailedToDownloadCveMetaData,
                    e,
                    "Exception thrown when trying to download CVE META file for {Year} from {SourceUri}",
                    year,
                    sourceMetaFileUrl);

                // This error should not block processing other data files.
                return new CveMetaFileDownloadResult(Error.FailedToDownloadCveMetaData, year);
            }
        }
    }
}