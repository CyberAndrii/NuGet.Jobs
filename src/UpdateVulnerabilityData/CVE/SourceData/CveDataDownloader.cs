// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;

namespace UpdateVulnerabilityData.CVE
{
    public class CveDataDownloader : ICveDataDownloader
    {
        public const string SourceFileFormat = "nvdcve-1.0-{0}.json.zip";
        public const string SourceUrlFormat = "https://nvd.nist.gov/feeds/json/cve/1.0/" + SourceFileFormat;

        private readonly HttpClient _httpClient;
        private readonly ILogger<CveDataDownloader> _logger;

        public CveDataDownloader(
            HttpClient httpClient,
            ILogger<CveDataDownloader> logger)
        {
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public async Task<CveFileDownloadResult> DownloadAndExtractJsonDataToDiskAsync(int year, string targetFilePath)
        {
            if (targetFilePath == null)
            {
                throw new ArgumentNullException(nameof(targetFilePath));
            }

            if (year < 2002 || year > DateTime.UtcNow.Year)
            {
                throw new ArgumentOutOfRangeException(nameof(year), "The requested year has no CVE data available.");
            }

            var sourceUrl = string.Format(CultureInfo.InvariantCulture, SourceUrlFormat, year);

            Stream fileStream = null;
            var stopwatch = Stopwatch.StartNew();

            try
            {
                // Download the file from the network to a temporary file.
                string etag;
                using (var response = await _httpClient.GetAsync(sourceUrl, HttpCompletionOption.ResponseHeadersRead))
                {
                    _logger.LogInformation(
                        "Received response {StatusCode}: {ReasonPhrase} of type {ContentType} for request {SourceUrl}",
                        response.StatusCode,
                        response.ReasonPhrase,
                        response.Content.Headers.ContentType,
                        sourceUrl);

                    if (response.StatusCode != HttpStatusCode.OK)
                    {
                        throw new InvalidOperationException($"Expected status code {HttpStatusCode.OK} for file download, actual: {response.StatusCode}");
                    }

                    etag = response.Headers.ETag.Tag.RemoveSurroundingQuotes();

                    using (var networkStream = await response.Content.ReadAsStreamAsync())
                    {
                        fileStream = File.Create(targetFilePath);

                        await networkStream.CopyToAsync(fileStream);
                    }
                }

                fileStream.Position = 0;

                stopwatch.Stop();

                _logger.LogInformation(
                    "Downloaded {FileSizeInBytes} bytes in {DownloadElapsedTime} seconds for request {SourceUri}",
                    fileStream.Length,
                    stopwatch.Elapsed.TotalSeconds,
                    sourceUrl);

                fileStream.Close();

                using (var archive = ZipFile.OpenRead(targetFilePath))
                {
                    var targetDirectory = new FileInfo(targetFilePath).Directory.FullName;

                    // The archive should only contain a single CSV file.
                    var jsonFile = archive.Entries.SingleOrDefault(e => e.FullName.EndsWith(".json", StringComparison.OrdinalIgnoreCase));
                    if (jsonFile == null)
                    {
                        throw new FileNotFoundException("The downloaded archive does not contain a single JSON file.");
                    }

                    // Gets the full path to ensure that relative segments are removed.
                    var destinationPath = Path.GetFullPath(Path.Combine(targetDirectory, jsonFile.FullName));

                    // Ordinal match is safest, case-sensitive volumes can be mounted within volumes that
                    // are case-insensitive.
                    if (destinationPath.StartsWith(targetDirectory, StringComparison.Ordinal))
                    {
                        jsonFile.ExtractToFile(destinationPath, overwrite: true);
                    }

                    return new CveFileDownloadResult(year, targetFilePath, destinationPath, etag);
                }
            }
            catch (Exception e)
            {
                _logger.LogError(
                    Error.FailedToDownloadCveData,
                    e,
                    "Exception thrown when trying to download CVE data from {SourceUri}",
                    sourceUrl);

                fileStream?.Dispose();

                throw;
            }
        }
    }
}