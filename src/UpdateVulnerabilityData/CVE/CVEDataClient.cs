// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using UpdateVulnerabilityData.Storage;

namespace UpdateVulnerabilityData.CVE
{
    public class CveDataClient : VulnerabilityDataClient, ICveDataClient
    {
        private static readonly string _localDataImportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-import");
        private static readonly string _localDataExportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-export");

        // The initial file contains all CVEs prior to and including 2002.
        // Loop all years until the current year.
        private static readonly int[] Years = Enumerable.Range(2002, DateTime.UtcNow.Year - 2001).ToArray();

        private readonly ICveDataDownloader _cveDataDownloader;
        private readonly ICveJsonFileParser _cveFileParser;

        public CveDataClient(
            ICveJsonFileParser cveFileParser,
            ICveDataDownloader cveDataDownloader,
            ILogger<CveDataClient> logger,
            IOptionsSnapshot<UpdateVulnerabilityDataConfiguration> configuration,
            IVulnerabilityDetailsStorage storage,
            ITelemetryService telemetryService)
            : base(configuration, logger, storage, telemetryService)
        {
            _cveFileParser = cveFileParser ?? throw new ArgumentNullException(nameof(cveFileParser));
            _cveDataDownloader = cveDataDownloader ?? throw new ArgumentNullException(nameof(cveDataDownloader));
        }

        public async Task ImportCveDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory)
        {
            if (sqlConnectionFactory == null)
            {
                throw new ArgumentNullException(nameof(sqlConnectionFactory));
            }

            // Ensure the target folders exist and are clean.
            PrepareLocalDirectories(_localDataImportFolder, _localDataExportFolder);

            // Check for the presence of the references file.
            // If it exists, it means the job already ran an initial import.
            var referencesFile = await Storage.ReadCveMetaFilesReferenceAsync();
            if (referencesFile != null)
            {
                Logger.LogError(
                    Error.CveMetaReferencesFileAlreadyExists,
                    $"The CVE META references file already exists, indicating an initial import already happened. Verify storage or run the job in {ExecutionMode.Update} mode.");

                return;
            }

            // Fetch all META files (in parallal)
            var metaFileDownloadResults = await DownloadAllSourceMetadataAsync();

            // Fetch all compressed ZIP streams (in parallel), 
            // and verify these files against their META info.
            var dataDownloadResults = await DownloadAllSourceDataAsync(metaFileDownloadResults.ToList());

            // Process the META files.
            foreach (var metaFileDownloadResult in metaFileDownloadResults)
            {
                // Save source data to backup location.
                await BackupSourceDataAsync(
                    metaFileDownloadResult.FilePath,
                    metaFileDownloadResult.ETag,
                    ContentType.PlainText);
            }

            // Process the data files.
            // Keep track of the processed CVE data by populating the reference file.
            var reference = new CveMetaFilesReference();

            foreach (var dataDownloadResult in dataDownloadResults)
            {
                // Parse (and flatten) the JSON-formatted source files.
                var parsedDocument = _cveFileParser.Parse(dataDownloadResult.FilePath);

                // Import projected data into database.
                try
                {
                    await ImportIntoDatabaseAsync(sqlConnectionFactory, parsedDocument);
                }
                catch (SqlException sqlException)
                {
                    Logger.LogError(
                        Error.FailedToImportCveDataIntoDatabase,
                        sqlException,
                        "Failed to import CVE data from file '{FileName}' for '{Year}' into target database.",
                        dataDownloadResult.FilePath,
                        dataDownloadResult.Year);

                    // Swallow exception and attempt to continue processing other files.
                    continue;
                }

                // Save source data to backup location.
                await BackupSourceDataAsync(
                    dataDownloadResult.PathToZipArchive,
                    dataDownloadResult.ETag,
                    ContentType.Zip);

                var metaFile = metaFileDownloadResults.Single(m => m.Year == dataDownloadResult.Year);

                reference.MetaFiles.Add(new CveMetaFileInfo
                {
                    JsonFileSize = metaFile.Metadata.JsonSize,
                    JsonFileSha256 = metaFile.Metadata.Sha256,
                    JsonFileName = new FileInfo(dataDownloadResult.FilePath).Name,
                    MetaFileName = new FileInfo(metaFile.FilePath).Name,
                    LastModifiedDate = metaFile.Metadata.LastModifiedDate,
                    Year = dataDownloadResult.Year,
                    ZipArchiveFileName = new FileInfo(dataDownloadResult.PathToZipArchive).Name,
                    ZipFileSize = metaFile.Metadata.ZipSize
                });
            }

            // Store CVE META status for future reference.
            if (reference.MetaFiles.Any())
            {
                await Storage.WriteCveMetaFilesReferenceAsync(reference);
            }
        }

        public async Task UpdateCveDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory)
        {
            // For reference: https://nvd.nist.gov/vuln/data-feeds#JSON_FEED

            // Retrieve the CVE META references file to determine status
            var referencesFile = await Storage.ReadCveMetaFilesReferenceAsync();
            if (referencesFile == null)
            {
                // The file doesn't exist and we are running in "update" mode.
                // Bail out, as we should first run the "initial import".

                var notSupportedMessage = "Required CVE META references file not found. Aborting CVE data update.";
                Logger.LogError(
                    Error.CveMetaReferencesFileNotFound,
                    notSupportedMessage);

                throw new NotSupportedException(notSupportedMessage);
            }

        }

        private async Task<ConcurrentBag<CveFileDownloadResult>> DownloadAllSourceDataAsync(
            IReadOnlyCollection<CveMetaFileDownloadResult> metaFileInfoCollection)
        {
            var downloadResults = new ConcurrentBag<CveFileDownloadResult>();
            var downloadTasks = Years.Select(year => Task.Run(async () =>
            {
                var pathToDownloadedArchive = Path.Combine(
                       _localDataImportFolder,
                       string.Format(CultureInfo.InvariantCulture, CveDataDownloader.SourceFileFormat, year));

                var metaFileInfoForYear = metaFileInfoCollection.SingleOrDefault(f => f.Year == year);
                if (!metaFileInfoForYear.Success)
                {
                    // The META file could not be downloaded successfully.
                    // Skip processing this year's CVE data.
                    return;
                }

                // Download CVE data archive.
                var downloadResult = await _cveDataDownloader.DownloadAndExtractJsonDataToDiskAsync(
                    year,
                    pathToDownloadedArchive,
                    metaFileInfoForYear);

                // Verify JSON data file against .META file
                // Verify SHA-256 against the published META file.
                if (!string.Equals(downloadResult.Sha256, metaFileInfoForYear.Metadata.Sha256, StringComparison.OrdinalIgnoreCase))
                {
                    // If there's a mismatch between expected SHA256 hash (as published in the META file) 
                    // and actual SHA256 hash (as calculated for the extracted JSON file containing CVE data),
                    // we should skip processing the CVE data file for this particular year.

                    Logger.LogWarning(
                        "Expected SHA256-hash (as published in META file for '{Year}') does not match actual SHA256-hash (as computed for CVE data file).",
                        year);

                    return;
                }

                downloadResults.Add(downloadResult);
            }));

            // Wait for all source files to be downloaded.
            await Task.WhenAll(downloadTasks);

            return downloadResults;
        }

        private async Task<ConcurrentBag<CveMetaFileDownloadResult>> DownloadAllSourceMetadataAsync()
        {
            var downloadResults = new ConcurrentBag<CveMetaFileDownloadResult>();
            var downloadTasks = Years.Select(year => Task.Run(async () =>
            {
                var pathToDownloadedMetaFile = Path.Combine(
                       _localDataImportFolder,
                       string.Format(CultureInfo.InvariantCulture, CveDataDownloader.SourceMetaFileFormat, year));

                var downloadResult = await _cveDataDownloader.DownloadAndParseSourceMetaFileAsync(year, pathToDownloadedMetaFile);

                downloadResults.Add(downloadResult);
            }));

            // Wait for all source files to be downloaded.
            await Task.WhenAll(downloadTasks);

            return downloadResults;
        }

        private async Task ImportIntoDatabaseAsync(
            Func<Task<SqlConnection>> sqlConnectionFactory,
            CveFlattenedJsonDocument parsedDocument)
        {
            // Import assumes clear target tables.

            using (var sqlConnection = await sqlConnectionFactory())
            {
                var dataTable = GetDataTable(SqlTable.Cves, sqlConnection);

                foreach (var cve in parsedDocument.Items)
                {
                    var dataRow = dataTable.NewRow();
                    dataRow["CveId"] = cve.Id;
                    dataRow["Description"] = cve.Description;
                    dataRow["PublishedDate"] = cve.PublishedDate;
                    dataRow["LastModifiedDate"] = cve.LastModifiedDate;

                    if (cve.CvssRating.HasValue)
                    {
                        dataRow["CvssRating"] = cve.CvssRating.Value;
                    }
                    else
                    {
                        dataRow["CvssRating"] = DBNull.Value;
                    }

                    dataRow["Status"] = CveImportHelper.DetermineStatus(cve.Description);
                    dataRow["Listed"] = CveImportHelper.DetermineListed(cve.Description);

                    dataTable.Rows.Add(dataRow);
                }

                var sqlBulkCopy = CreateNewSqlBulkCopy(sqlConnection, dataTable.TableName);

                // This avoids identity insert issues, as these are db-generated.
                foreach (DataColumn column in dataTable.Columns)
                {
                    sqlBulkCopy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                }

                await sqlBulkCopy.WriteToServerAsync(dataTable);
            }
        }
    }
}