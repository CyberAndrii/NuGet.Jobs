// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NuGet.Services.Entities;
using NuGetGallery;
using UpdateVulnerabilityData.Storage;

namespace UpdateVulnerabilityData.CVE
{
    public class CveDataClient : VulnerabilityDataClient, ICveDataClient
    {
        private static readonly string LocalDataImportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-import");
        private static readonly string LocalDataExportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-export");

        // The initial file contains all CVEs prior to and including 2002.
        // Loop all years until the current year.
        private static readonly int[] Years = Enumerable.Range(2002, DateTime.UtcNow.Year - 2001).ToArray();

        private readonly ICveDataDownloader _cveDataDownloader;
        private readonly ICveJsonFileParser _cveFileParser;

        public CveDataClient(
            ICveJsonFileParser cveFileParser,
            ICveDataDownloader cveDataDownloader,
            ILogger<CveDataClient> logger,
            IOptionsSnapshot<UpdateVulnerabilityDataConfiguration> configuration,
            IVulnerabilityDetailsStorage storage,
            ITelemetryService telemetryService)
            : base(configuration, logger, storage, telemetryService)
        {
            _cveFileParser = cveFileParser ?? throw new ArgumentNullException(nameof(cveFileParser));
            _cveDataDownloader = cveDataDownloader ?? throw new ArgumentNullException(nameof(cveDataDownloader));
        }

        public async Task ImportCveDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory)
        {
            if (sqlConnectionFactory == null)
            {
                throw new ArgumentNullException(nameof(sqlConnectionFactory));
            }

            // Ensure the target folders exist and are clean.
            PrepareLocalDirectories(LocalDataImportFolder, LocalDataExportFolder);

            // Check for the presence of the references file.
            // If it exists, it means the job already ran an initial import.
            var referencesFile = await Storage.ReadCveMetaFilesReferenceAsync();
            if (referencesFile != null)
            {
                Logger.LogError(
                    Error.CveMetaReferencesFileAlreadyExists,
                    $"The CVE META references file already exists, indicating an initial import already happened. Verify storage or run the job in {ExecutionMode.Update} mode.");

                return;
            }

            // Fetch all META files (in parallal)
            var metaFileDownloadResults = await DownloadAllSourceMetadataAsync();

            // Fetch all compressed ZIP streams (in parallel), 
            // and verify these files against their META info.
            var dataDownloadResults = await DownloadAllSourceDataAsync(metaFileDownloadResults.ToList());

            // Process the META files.
            foreach (var metaFileDownloadResult in metaFileDownloadResults)
            {
                // Save source data to backup location.
                await BackupSourceDataAsync(
                    metaFileDownloadResult.FilePath,
                    metaFileDownloadResult.ETag,
                    ContentType.PlainText);
            }

            // Process the data files.
            // Keep track of the processed CVE data by populating the reference file.
            var reference = new CveMetaFilesReference();
            foreach (var dataDownloadResult in dataDownloadResults)
            {
                // Parse (and flatten) the JSON-formatted source files.
                var parsedDocument = _cveFileParser.Parse(dataDownloadResult.FilePath);

                // Import projected data into database.
                try
                {
                    await ImportIntoDatabaseAsync(sqlConnectionFactory, parsedDocument);
                }
                catch (SqlException sqlException)
                {
                    Logger.LogError(
                        Error.FailedToImportCveDataIntoDatabase,
                        sqlException,
                        "Failed to import CVE data from file '{FileName}' for '{Year}' into target database.",
                        dataDownloadResult.FilePath,
                        dataDownloadResult.Year);

                    // Swallow exception and attempt to continue processing other files.
                    continue;
                }

                // Save source data to backup location.
                await BackupSourceDataAsync(
                    dataDownloadResult.PathToZipArchive,
                    dataDownloadResult.ETag,
                    ContentType.Zip);

                var metaFile = metaFileDownloadResults.Single(m => m.Year == dataDownloadResult.Year);

                reference.MetaFiles.Add(CreateCveMetaFileInfo(metaFile, dataDownloadResult));
            }

            // Store CVE META status for future reference.
            if (reference.MetaFiles.Any())
            {
                await Storage.WriteCveMetaFilesReferenceAsync(reference);
            }
        }

        private static CveMetaFileInfo CreateCveMetaFileInfo(
            CveMetaFileDownloadResult metaFileDownloadResult,
            CveFileDownloadResult dataDownloadResult = null)
        {
            var metaFileInfo = new CveMetaFileInfo
            {
                JsonFileSize = metaFileDownloadResult.Metadata.JsonSize,
                JsonFileSha256 = metaFileDownloadResult.Metadata.Sha256,
                MetaFileName = new FileInfo(metaFileDownloadResult.FilePath).Name,
                LastModifiedDate = metaFileDownloadResult.Metadata.LastModifiedDate,
                Year = metaFileDownloadResult.Year,
                ZipFileSize = metaFileDownloadResult.Metadata.ZipSize
            };

            if (dataDownloadResult != null)
            {
                // Enrich with data file info when available
                metaFileInfo.JsonFileName = new FileInfo(dataDownloadResult.FilePath).Name;
                metaFileInfo.ZipArchiveFileName = new FileInfo(dataDownloadResult.PathToZipArchive).Name;
            }

            return metaFileInfo;
        }

        public async Task UpdateCveDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory)
        {
            TelemetryService.TrackUpdateCveDataStartedEvent();

            // Ensure the target folders exist and are clean.
            PrepareLocalDirectories(LocalDataImportFolder, LocalDataExportFolder);

            // Retrieve the CVE META references file to determine status
            var oldReference = await Storage.ReadCveMetaFilesReferenceAsync();
            if (oldReference == null)
            {
                // The file doesn't exist and we are running in "update" mode.
                // Bail out, as we should first run the "initial import".

                var notSupportedMessage = "Required CVE META references file not found. Aborting CVE data update.";
                Logger.LogError(
                    Error.CveMetaReferencesFileNotFound,
                    notSupportedMessage);

                throw new NotSupportedException(notSupportedMessage);
            }

            // Fetch all META files (in parallal)
            var metaFileDownloadResults = await DownloadAllSourceMetadataAsync();

            // Build new references file from latest download results
            var newReference = new CveMetaFilesReference();
            foreach (var metaFileDownloadResult in metaFileDownloadResults)
            {
                newReference.MetaFiles.Add(CreateCveMetaFileInfo(metaFileDownloadResult));
            }

            // Compare old vs new and determine CVE data to be updated.
            var metaFilesToBeProcessed = CompareCveMetaReferencesFiles(oldReference, newReference);
            if (metaFilesToBeProcessed.Any())
            {
                // Download the CVE data and .META file from the MODIFIED feed.
                // We download the .META file too to verify integrity of the downloaded data files.                

                var pathToDownloadedModifiedMetaFile = Path.Combine(
                       LocalDataImportFolder,
                       CveDataDownloader.ModifiedMetaFileName);
                var pathToDownloadedModifiedFile = Path.Combine(
                       LocalDataImportFolder,
                       CveDataDownloader.ModifiedFileName);

                var modifiedMetaData = await _cveDataDownloader.DownloadAndParseModifiedMetaFileAsync(
                    pathToDownloadedModifiedMetaFile);

                var modifiedData = await _cveDataDownloader.DownloadAndExtractModifiedDataToDisk(
                    pathToDownloadedModifiedFile,
                    modifiedMetaData.Metadata.ZipSize);

                // Parse (and flatten) the JSON-formatted MODIFIED file.
                var parsedDocument = _cveFileParser.Parse(modifiedData.FilePath);

                await UpdateCveDataAsync(sqlConnectionFactory, parsedDocument);
            }

            TelemetryService.TrackUpdateCveDataCompletedEvent(metaFilesToBeProcessed.Count);
        }

        private IReadOnlyCollection<CveMetaFileInfo> CompareCveMetaReferencesFiles(
            CveMetaFilesReference oldReference,
            CveMetaFilesReference newReference)
        {
            var yearsToBeUpdated = new List<CveMetaFileInfo>();

            foreach (var newMetaFile in newReference.MetaFiles)
            {
                var oldMetaFile = oldReference.MetaFiles.SingleOrDefault(m => m.Year == newMetaFile.Year);
                if (oldMetaFile == null)
                {
                    // No reference exists for this year. Happy New Year!
                    yearsToBeUpdated.Add(newMetaFile);
                }
                else
                {
                    // Check JSON data-file SHA-256 hash for differences.
                    if (!string.Equals(newMetaFile.JsonFileSha256, oldMetaFile.JsonFileSha256)
                        || newMetaFile.LastModifiedDate != oldMetaFile.LastModifiedDate)
                    {
                        yearsToBeUpdated.Add(newMetaFile);
                    }
                }
            }

            return yearsToBeUpdated;
        }

        private async Task<ConcurrentBag<CveFileDownloadResult>> DownloadAllSourceDataAsync(
            IReadOnlyCollection<CveMetaFileDownloadResult> metaFileInfoCollection)
        {
            var downloadResults = new ConcurrentBag<CveFileDownloadResult>();
            var downloadTasks = Years.Select(year => Task.Run(async () =>
            {
                var pathToDownloadedArchive = Path.Combine(
                       LocalDataImportFolder,
                       string.Format(CultureInfo.InvariantCulture, CveDataDownloader.SourceFileFormat, year));

                var metaFileInfoForYear = metaFileInfoCollection.SingleOrDefault(f => f.Year == year);
                if (!metaFileInfoForYear.Success)
                {
                    // The META file could not be downloaded successfully.
                    // Skip processing this year's CVE data.
                    return;
                }

                // Download CVE data archive.
                var downloadResult = await _cveDataDownloader.DownloadAndExtractJsonDataToDiskAsync(
                    year,
                    pathToDownloadedArchive,
                    metaFileInfoForYear.Metadata.ZipSize);

                // Verify JSON data file against .META file
                // Verify SHA-256 against the published META file.
                if (!string.Equals(downloadResult.Sha256, metaFileInfoForYear.Metadata.Sha256, StringComparison.OrdinalIgnoreCase))
                {
                    // If there's a mismatch between expected SHA256 hash (as published in the META file) 
                    // and actual SHA256 hash (as calculated for the extracted JSON file containing CVE data),
                    // we should skip processing the CVE data file for this particular year.

                    Logger.LogWarning(
                        "Expected SHA256-hash (as published in META file for '{Year}') does not match actual SHA256-hash (as computed for CVE data file).",
                        year);

                    return;
                }

                downloadResults.Add(downloadResult);
            }));

            // Wait for all source files to be downloaded.
            await Task.WhenAll(downloadTasks);

            return downloadResults;
        }

        private async Task<ConcurrentBag<CveMetaFileDownloadResult>> DownloadAllSourceMetadataAsync()
        {
            var downloadResults = new ConcurrentBag<CveMetaFileDownloadResult>();
            var downloadTasks = Years.Select(year => Task.Run(async () =>
            {
                var pathToDownloadedMetaFile = Path.Combine(
                       LocalDataImportFolder,
                       string.Format(CultureInfo.InvariantCulture, CveDataDownloader.SourceMetaFileFormat, year));

                var downloadResult = await _cveDataDownloader.DownloadAndParseSourceMetaFileAsync(year, pathToDownloadedMetaFile);

                downloadResults.Add(downloadResult);
            }));

            // Wait for all source files to be downloaded.
            await Task.WhenAll(downloadTasks);

            return downloadResults;
        }

        private async Task ImportIntoDatabaseAsync(
            Func<Task<SqlConnection>> sqlConnectionFactory,
            CveFlattenedJsonDocument parsedDocument)
        {
            // Import assumes clear target tables.

            using (var sqlConnection = await sqlConnectionFactory())
            {
                var dataTable = GetDataTable(SqlTable.Cves, sqlConnection);

                foreach (var cve in parsedDocument.Items)
                {
                    var dataRow = dataTable.NewRow();
                    dataRow["CveId"] = cve.Id;
                    dataRow["Description"] = cve.Description;
                    dataRow["PublishedDate"] = cve.PublishedDate;
                    dataRow["LastModifiedDate"] = cve.LastModifiedDate;

                    if (cve.CvssRating.HasValue)
                    {
                        dataRow["CvssRating"] = cve.CvssRating.Value;
                    }
                    else
                    {
                        dataRow["CvssRating"] = DBNull.Value;
                    }

                    dataRow["Status"] = CveImportHelper.DetermineStatus(cve.Description);
                    dataRow["Listed"] = CveImportHelper.DetermineListed(cve.Description);

                    dataTable.Rows.Add(dataRow);
                }

                var sqlBulkCopy = CreateNewSqlBulkCopy(sqlConnection, dataTable.TableName);

                // This avoids identity insert issues, as these are db-generated.
                foreach (DataColumn column in dataTable.Columns)
                {
                    sqlBulkCopy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                }

                await sqlBulkCopy.WriteToServerAsync(dataTable);
            }
        }

        private async Task UpdateCveDataAsync(
            Func<Task<SqlConnection>> sqlConnectionFactory,
            CveFlattenedJsonDocument parsedDocument)
        {
            // The parsed document contains the most recent changes to CVE data.
            // It is possible that some of these changes are already processed.
            // Instead of re-downloading all CVE data files, we only download the CVE-Modified data file,
            // as it contains only the modified data, which results in a much smaller file to download and process.
            // Check by CveId and LastModifiedDate to only process new changes.
            using (var sqlConnection = await sqlConnectionFactory())
            {
                var entitiesContext = new EntitiesContext(sqlConnection, readOnly: false);

                var saveChanges = false;

                foreach (var updatedCve in parsedDocument.Items)
                {
                    var existingCve = entitiesContext.Cves.SingleOrDefault(e => e.CveId == updatedCve.Id);
                    if (existingCve == null)
                    {
                        // Inserting new CVE record.
                        var newCve = new Cve
                        {
                            CveId = updatedCve.Id,
                            CvssRating = updatedCve.CvssRating,
                            Description = updatedCve.Description,
                            LastModifiedDate = updatedCve.LastModifiedDate,
                            Listed = CveImportHelper.DetermineListed(updatedCve.Description),
                            PublishedDate = updatedCve.PublishedDate,
                            Status = CveImportHelper.DetermineStatus(updatedCve.Description)
                        };

                        entitiesContext.Cves.Add(newCve);

                        Logger.LogInformation("Creating new CVE with ID '{CveId}'", newCve.CveId);

                        TelemetryService.TrackCreatedNewCve(newCve.CveId);

                        saveChanges = true;
                    }
                    else if (existingCve.LastModifiedDate != updatedCve.LastModifiedDate)
                    {
                        // Updating existing CVE record.
                        existingCve.CvssRating = updatedCve.CvssRating;
                        existingCve.Description = updatedCve.Description;
                        existingCve.LastModifiedDate = updatedCve.LastModifiedDate;
                        existingCve.Listed = CveImportHelper.DetermineListed(updatedCve.Description);
                        existingCve.PublishedDate = updatedCve.PublishedDate;
                        existingCve.Status = CveImportHelper.DetermineStatus(updatedCve.Description);

                        Logger.LogInformation("Updating CVE with ID '{CveId}'", existingCve.CveId);

                        TelemetryService.TrackUpdatedCve(existingCve.CveId);

                        saveChanges = true;
                    }
                }

                // Commit changes to the database.
                if (saveChanges)
                {
                    await entitiesContext.SaveChangesAsync();
                }
            }
        }
    }
}