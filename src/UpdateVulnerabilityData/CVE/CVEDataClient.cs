// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;

namespace UpdateVulnerabilityData.CVE
{
    public class CVEDataClient : VulnerabilityDataClient, ICVEDataClient
    {
        private static readonly string _localDataImportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-import");
        private static readonly string _localDataExportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-export");

        private readonly ICVEDataDownloader _cveDataDownloader;
        private readonly ICVEJsonFileParser _cveFileParser;

        public CVEDataClient(
            ICVEJsonFileParser cveFileParser,
            ICVEDataDownloader cveDataDownloader,
            IOptionsSnapshot<UpdateVulnerabilityDataConfiguration> configuration)
            : base(configuration)
        {
            _cveFileParser = cveFileParser ?? throw new ArgumentNullException(nameof(cveFileParser));
            _cveDataDownloader = cveDataDownloader ?? throw new ArgumentNullException(nameof(cveDataDownloader));
        }

        public async Task RefreshCVEDataAsync(SqlConnection sqlConnection, CancellationToken cancellationToken)
        {
            if (sqlConnection == null)
            {
                throw new ArgumentNullException(nameof(sqlConnection));
            }

            if (cancellationToken == null)
            {
                throw new ArgumentNullException(nameof(cancellationToken));
            }

            // Ensure the target folders exist and are clean.
            PrepareLocalDirectories(_localDataImportFolder, _localDataExportFolder);

            // Fetch all compressed ZIP streams for CVE data from 2002 up until the current year included.
            for (int year = 2002; year <= DateTime.UtcNow.Year; year++)
            {
                var pathToDownloadedArchive = Path.Combine(
                    _localDataImportFolder,
                    string.Format(CultureInfo.InvariantCulture, CVEDataDownloader.SourceFileFormat, year));

                var extractedJsonFilePath = await _cveDataDownloader.DownloadAndExtractJsonDataToDiskAsync(year, pathToDownloadedArchive, cancellationToken);

                // Parse (and flatten) the JSON-formatted source file.
                var parsedDocument = _cveFileParser.Parse(extractedJsonFilePath);

                // Save projected JSON file to disk.
                SaveProjectedJsonFileToDisk(year, parsedDocument);

                // Import projected data into database.
                await ImportIntoDatabase(sqlConnection, parsedDocument, cancellationToken);

                // Save source data to backup location.
                await BackupSourceData(extractedJsonFilePath);
            }
        }

        private async Task ImportIntoDatabase(SqlConnection sqlConnection, CVEFlattenedJsonDocument parsedDocument, CancellationToken cancellationToken)
        {
            // todo
        }

        private async Task BackupSourceData(string extractedJsonFilePath)
        {
            // todo
        }

        private void SaveProjectedJsonFileToDisk(int year, CVEFlattenedJsonDocument document)
        {
            var targetFilePath = Path.Combine(_localDataExportFolder, $"cve-{year}.json");
            File.WriteAllText(targetFilePath, JsonConvert.SerializeObject(document, Formatting.None));
        }
    }
}