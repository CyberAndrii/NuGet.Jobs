// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using UpdateVulnerabilityData.Storage;

namespace UpdateVulnerabilityData.CVE
{
    public class CveDataClient : VulnerabilityDataClient, ICveDataClient
    {
        private static readonly string _localDataImportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-import");
        private static readonly string _localDataExportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-export");

        private readonly ICveDataDownloader _cveDataDownloader;
        private readonly ICveJsonFileParser _cveFileParser;

        public CveDataClient(
            ICveJsonFileParser cveFileParser,
            ICveDataDownloader cveDataDownloader,
            ILogger<CveDataClient> logger,
            IOptionsSnapshot<UpdateVulnerabilityDataConfiguration> configuration,
            IBackupDestination backupDestination,
            ITelemetryService telemetryService)
            : base(configuration, logger, backupDestination, telemetryService)
        {
            _cveFileParser = cveFileParser ?? throw new ArgumentNullException(nameof(cveFileParser));
            _cveDataDownloader = cveDataDownloader ?? throw new ArgumentNullException(nameof(cveDataDownloader));
        }

        public async Task ImportCveDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory)
        {
            if (sqlConnectionFactory == null)
            {
                throw new ArgumentNullException(nameof(sqlConnectionFactory));
            }

            // Ensure the target folders exist and are clean.
            PrepareLocalDirectories(_localDataImportFolder, _localDataExportFolder);

            // The initial file contains all CVEs prior to and including 2002.
            // Loop all years until the current year.
            var years = Enumerable.Range(2002, DateTime.UtcNow.Year - 2001).ToArray();

            // Fetch all META files (in parallal)
            var metaFileDownloadResults = await DownloadAllSourceMetadataAsync(years);

            // Fetch all compressed ZIP streams (in parallel), 
            // and verify these files against their META info.
            var dataDownloadResults = await DownloadAllSourceDataAsync(years, metaFileDownloadResults.ToList());

            // Process the META files.
            foreach (var metaFileDownloadResult in metaFileDownloadResults)
            {
                // Save source data to backup location.
                await BackupSourceDataAsync(
                    metaFileDownloadResult.FilePath,
                    metaFileDownloadResult.ETag,
                    ContentType.PlainText);
            }

            // Process the data files.
            foreach (var dataDownloadResult in dataDownloadResults)
            {
                // Parse (and flatten) the JSON-formatted source files.
                var parsedDocument = _cveFileParser.Parse(dataDownloadResult.FilePath);

                // Save projected JSON file to disk.
                SaveProjectedJsonFileToDisk(dataDownloadResult.Year, parsedDocument);

                // Save source data to backup location.
                await BackupSourceDataAsync(
                    dataDownloadResult.PathToZipArchive,
                    dataDownloadResult.ETag,
                    ContentType.Zip);

                // Import projected data into database.
                await ImportIntoDatabaseAsync(sqlConnectionFactory, parsedDocument);
            }
        }

        public async Task UpdateCveDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory)
        {
            // For reference: https://nvd.nist.gov/vuln/data-feeds#JSON_FEED

            throw new NotImplementedException();
        }

        private async Task<ConcurrentBag<CveFileDownloadResult>> DownloadAllSourceDataAsync(
            int[] years,
            IReadOnlyCollection<CveMetaFileDownloadResult> metaFileInfoCollection)
        {
            var downloadResults = new ConcurrentBag<CveFileDownloadResult>();
            var downloadTasks = years.Select(year => Task.Run(async () =>
            {
                var pathToDownloadedArchive = Path.Combine(
                       _localDataImportFolder,
                       string.Format(CultureInfo.InvariantCulture, CveDataDownloader.SourceFileFormat, year));

                var metaFileInfoForYear = metaFileInfoCollection.SingleOrDefault(f => f.Year == year);
                if (!metaFileInfoForYear.Success)
                {
                    // The META file could not be downloaded successfully.
                    // Skip processing this year's CVE data.
                    return;
                }

                // Download CVE data archive.
                var downloadResult = await _cveDataDownloader.DownloadAndExtractJsonDataToDiskAsync(
                    year,
                    pathToDownloadedArchive,
                    metaFileInfoForYear);

                // Verify JSON data file against .META file
                // Verify SHA-256 against the published META file.
                if (!string.Equals(downloadResult.Sha256, metaFileInfoForYear.Metadata.Sha256, StringComparison.OrdinalIgnoreCase))
                {
                    // If there's a mismatch between expected SHA256 hash (as published in the META file) 
                    // and actual SHA256 hash (as calculated for the extracted JSON file containing CVE data),
                    // we should skip processing the CVE data file for this particular year.

                    Logger.LogWarning(
                        "Expected SHA256-hash (as published in META file for '{Year}') does not match actual SHA256-hash (as computed for CVE data file).",
                        year);

                    return;
                }

                downloadResults.Add(downloadResult);
            }));

            // Wait for all source files to be downloaded.
            await Task.WhenAll(downloadTasks);

            return downloadResults;
        }

        private async Task<ConcurrentBag<CveMetaFileDownloadResult>> DownloadAllSourceMetadataAsync(int[] years)
        {
            var downloadResults = new ConcurrentBag<CveMetaFileDownloadResult>();
            var downloadTasks = years.Select(year => Task.Run(async () =>
            {
                var pathToDownloadedMetaFile = Path.Combine(
                       _localDataImportFolder,
                       string.Format(CultureInfo.InvariantCulture, CveDataDownloader.SourceMetaFileFormat, year));

                var downloadResult = await _cveDataDownloader.DownloadAndParseSourceMetaFileAsync(year, pathToDownloadedMetaFile);

                downloadResults.Add(downloadResult);
            }));

            // Wait for all source files to be downloaded.
            await Task.WhenAll(downloadTasks);

            return downloadResults;
        }

        private async Task ImportIntoDatabaseAsync(
            Func<Task<SqlConnection>> sqlConnectionFactory,
            CveFlattenedJsonDocument parsedDocument)
        {
            // Import assumes clear target tables.

            try
            {
                using (var sqlConnection = await sqlConnectionFactory())
                {
                    var dataTable = GetDataTable(SqlTable.Cves, sqlConnection);

                    foreach (var cve in parsedDocument.Items)
                    {
                        var dataRow = dataTable.NewRow();
                        dataRow["CveId"] = cve.Id;
                        dataRow["Description"] = cve.Description;
                        dataRow["PublishedDate"] = cve.PublishedDate;
                        dataRow["LastModifiedDate"] = cve.LastModifiedDate;

                        if (cve.CvssRating.HasValue)
                        {
                            dataRow["CvssRating"] = cve.CvssRating.Value;
                        }
                        else
                        {
                            dataRow["CvssRating"] = DBNull.Value;
                        }

                        dataRow["Status"] = CveImportHelper.DetermineStatus(cve.Description);
                        dataRow["Listed"] = CveImportHelper.DetermineListed(cve.Description);

                        dataTable.Rows.Add(dataRow);
                    }

                    var sqlBulkCopy = CreateNewSqlBulkCopy(sqlConnection, dataTable.TableName);

                    // This avoids identity insert issues, as these are db-generated.
                    foreach (DataColumn column in dataTable.Columns)
                    {
                        sqlBulkCopy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                    }

                    await sqlBulkCopy.WriteToServerAsync(dataTable);
                }
            }
            catch (Exception e)
            {

                throw;
            }

        }

        private void SaveProjectedJsonFileToDisk(int year, CveFlattenedJsonDocument document)
        {
            var targetFilePath = Path.Combine(_localDataExportFolder, $"cve-{year}.json");
            File.WriteAllText(targetFilePath, JsonConvert.SerializeObject(document, Formatting.None));
        }
    }
}