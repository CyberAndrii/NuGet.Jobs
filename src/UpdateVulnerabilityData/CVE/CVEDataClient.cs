// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Collections.Concurrent;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;

namespace UpdateVulnerabilityData.CVE
{
    public class CveDataClient : VulnerabilityDataClient, ICveDataClient
    {
        private static readonly string _localDataImportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-import");
        private static readonly string _localDataExportFolder = Path.Combine(Environment.CurrentDirectory, "CVE-data-export");

        private readonly ICveDataDownloader _cveDataDownloader;
        private readonly ICveJsonFileParser _cveFileParser;

        public CveDataClient(
            ICveJsonFileParser cveFileParser,
            ICveDataDownloader cveDataDownloader,
            ILogger<CveDataClient> logger,
            IOptionsSnapshot<UpdateVulnerabilityDataConfiguration> configuration)
            : base(configuration, logger)
        {
            _cveFileParser = cveFileParser ?? throw new ArgumentNullException(nameof(cveFileParser));
            _cveDataDownloader = cveDataDownloader ?? throw new ArgumentNullException(nameof(cveDataDownloader));
        }

        public async Task ImportCveDataAsync(Func<Task<SqlConnection>> sqlConnectionFactory, CancellationToken cancellationToken)
        {
            if (sqlConnectionFactory == null)
            {
                throw new ArgumentNullException(nameof(sqlConnectionFactory));
            }

            if (cancellationToken == null)
            {
                throw new ArgumentNullException(nameof(cancellationToken));
            }

            // Ensure the target folders exist and are clean.
            PrepareLocalDirectories(_localDataImportFolder, _localDataExportFolder);

            // Fetch all compressed ZIP streams (in parallel)
            var downloadResults = await DownloadAllSourceDataAsync(cancellationToken);

            // Process the files.
            foreach (var downloadResult in downloadResults)
            {
                // Parse (and flatten) the JSON-formatted source files.
                var parsedDocument = _cveFileParser.Parse(downloadResult.PathToJsonFile);

                // Save projected JSON file to disk.
                SaveProjectedJsonFileToDisk(downloadResult.Year, parsedDocument);

                // Save source data to backup location.
                await BackupSourceData(downloadResult.PathToZipArchive, downloadResult.ETag);

                // Import projected data into database.
                await ImportIntoDatabase(sqlConnectionFactory, parsedDocument);
            }
        }

        private async Task<ConcurrentBag<CveFileDownloadResult>> DownloadAllSourceDataAsync(CancellationToken cancellationToken)
        {
            // The initial file contains all CVEs prior to and including 2002.
            // Loop all years until the current year.
            var years = Enumerable.Range(2002, DateTime.UtcNow.Year - 2001).ToArray();
            var downloadResults = new ConcurrentBag<CveFileDownloadResult>();
            var downloadTasks = years.Select(year => Task.Run(async () =>
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    return;
                }

                var pathToDownloadedArchive = Path.Combine(
                       _localDataImportFolder,
                       string.Format(CultureInfo.InvariantCulture, CveDataDownloader.SourceFileFormat, year));

                var downloadResult = await _cveDataDownloader.DownloadAndExtractJsonDataToDiskAsync(year, pathToDownloadedArchive, cancellationToken);

                downloadResults.Add(downloadResult);
            },
            cancellationToken));

            // Wait for all source files to be downloaded.
            await Task.WhenAll(downloadTasks);

            return downloadResults;
        }

        private async Task ImportIntoDatabase(
            Func<Task<SqlConnection>> sqlConnectionFactory,
            CveFlattenedJsonDocument parsedDocument)
        {
            // Import assumes clear target tables.

            try
            {
                using (var sqlConnection = await sqlConnectionFactory())
                {
                    var dataTable = GetDataTable(SqlTable.Cves, sqlConnection);

                    foreach (var cve in parsedDocument.Items)
                    {
                        var dataRow = dataTable.NewRow();
                        dataRow["CveId"] = cve.Id;
                        dataRow["Description"] = cve.Description;
                        dataRow["PublishedDate"] = cve.PublishedDate;
                        dataRow["LastModifiedDate"] = cve.LastModifiedDate;

                        if (cve.CvssRating.HasValue)
                        {
                            dataRow["CvssRating"] = cve.CvssRating.Value;
                        }
                        else
                        {
                            dataRow["CvssRating"] = DBNull.Value;
                        }

                        dataRow["Status"] = CveHelper.DetermineStatus(cve.Description);
                        dataRow["Listed"] = CveHelper.DetermineListed(cve.Description);

                        dataTable.Rows.Add(dataRow);
                    }

                    var sqlBulkCopy = CreateNewSqlBulkCopy(sqlConnection, dataTable.TableName);

                    // This avoids identity insert issues, as these are db-generated.
                    foreach (DataColumn column in dataTable.Columns)
                    {
                        sqlBulkCopy.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                    }

                    await sqlBulkCopy.WriteToServerAsync(dataTable);
                }
            }
            catch (Exception e)
            {

                throw;
            }

        }

        private async Task BackupSourceData(string sourceFilePath, string eTag)
        {
            // todo: backup to blob storage
        }

        private void SaveProjectedJsonFileToDisk(int year, CveFlattenedJsonDocument document)
        {
            var targetFilePath = Path.Combine(_localDataExportFolder, $"cve-{year}.json");
            File.WriteAllText(targetFilePath, JsonConvert.SerializeObject(document, Formatting.None));
        }
    }
}